/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v1/auth/token": {
    /**
     * Generate a new Access Token which can be used to authenticate against
     * the Audience API.
     *
     * An API key is required in the HTTP Authorization header.
     */
    post: operations["generate_tokens_v1_auth_token_post"];
  };
  "/v1/auth/introspect-token": {
    /**
     * Inspect an Access token generated by the Fictioneers Authorization service.
     *
     * Requires a secret API Key in the HTTP Authorization header.
     */
    post: operations["token_info_v1_auth_introspect_token_post"];
  };
  "/v1/users/me": {
    /** Retrieve detailed representation of the current user (and user story state). */
    get: operations["get_user_me_v1_users_me_get"];
    /** Delete the user and any user associated objects from the current timeline. */
    delete: operations["delete_user_v1_users_me_delete"];
  };
  "/v1/users": {
    /** Create a new audience user for a Fictioneers powered experience. */
    post: operations["create_user_v1_users_post"];
  };
  "/v1/user-story-state": {
    /** Representation of authenticated users narrative story state. */
    get: operations["get_user_story_state_v1_user_story_state_get"];
    /**
     * Updates the current timeline event ID for the user, adding the previous value to
     * the history.
     */
    patch: operations["patch_user_story_state_v1_user_story_state_patch"];
  };
  "/v1/user-story-state/progress-events": {
    /** Progress events based on the authenticated user available transition events. */
    post: operations["step_events_for_user_via_post_v1_user_story_state_progress_events_post"];
  };
  "/v1/user-timeline-events": {
    /**
     * List endpoint for user timeline events ordered by step index (including events
     * in an INITIAL state).
     */
    get: operations["list_timeline_events_for_user_v1_user_timeline_events_get"];
  };
  "/v1/user-timeline-events/{timeline_event_id}": {
    /** Patch endpoint for user timeline events. */
    patch: operations["update_user_timeline_event_v1_user_timeline_events__timeline_event_id__patch"];
  };
  "/v1/user-timeline-event-state-changes": {
    /**
     * List endpoint for user timeline event state changes implicitly filtered by the
     * authenticated user ID.
     */
    get: operations["get_user_timeline_event_state_changes_v1_user_timeline_event_state_changes_get"];
  };
  "/v1/timelines": {
    /** List all published timelines which users can be placed on. */
    get: operations["get_timelines_v1_timelines_get"];
  };
  "/v1/timelines/{timeline_id}": {
    /** Representation of a single timeline. */
    get: operations["get_timeline_v1_timelines__timeline_id__get"];
  };
  "/v1/timelines/{timeline_id}/timeline-events": {
    /** Lists all timeline events on a specific timeline. */
    get: operations["list_timeline_timeline_events_v1_timelines__timeline_id__timeline_events_get"];
  };
  "/v1/timelines/{timeline_id}/users": {
    /** List of all users on timeline. */
    get: operations["get_timeline_users_v1_timelines__timeline_id__users_get"];
    /** Delete all users on a timeline. */
    delete: operations["delete_all_timeline_users_v1_timelines__timeline_id__users_delete"];
  };
  "/v1/timelines/{timeline_id}/users/{user_id}": {
    /** Retrieves timeline user. */
    get: operations["get_timeline_user_v1_timelines__timeline_id__users__user_id__get"];
    /** Delete timeline user. */
    delete: operations["delete_timeline_user_v1_timelines__timeline_id__users__user_id__delete"];
  };
  "/v1/timelines/{timeline_id}/event-state-changes": {
    /** Returns all event state changes filtered by timeline. */
    get: operations["list_all_timeline_event_state_changes_v1_timelines__timeline_id__event_state_changes_get"];
  };
}

export interface components {
  schemas: {
    /**
     * Beat
     * @description Represents a beat object on a narrative timeline.
     */
    Beat: {
      /**
       * Id
       * @description ID of the beat.
       * @example KLJviYC7MNS7owT7ujWtb7rIHB6
       */
      id?: string;
      /**
       * Name
       * @description Name of the beat.
       * @example Act 1 Beat 3
       */
      name?: string;
    };
    /**
     * ContentIntegration
     * @description Represents content referenced in an external data source to an event state.
     */
    ContentIntegration: {
      /**
       * Content Id
       * @example MN7S90NBDJ
       */
      content_id: string;
      /**
       * Content Type
       * @example BlogPost
       */
      content_type: string;
      /**
       * Provider Id
       * @example Contentful
       */
      provider_id: string;
    };
    /**
     * CreateUserRequest
     * @description Used when creating a new user entity.
     *
     * The timeline ID and timezone is explicitly provided by the client - while the user
     * email address and other mandatory fields are extracted from the verified JWT token
     * sent in the authorization header.
     */
    CreateUserRequest: {
      /**
       * Timeline ID the user should be placed on
       * @example 5UNDJoOUBDfSoMlW97a
       */
      published_timeline_id: string;
      /**
       * Timezone for the narrative story progression system
       * @example Europe/London
       */
      timezone: string;
      /**
       * Disable Time Guards
       * @description Feature flag to bypass time based guards per user.
       * @default false
       * @example false
       */
      disable_time_guards?: boolean;
      /**
       * Pause At Beats
       * @description Feature flag to toggle pausing execution of progression at beat markers.
       * @default false
       * @example false
       */
      pause_at_beats?: boolean;
    };
    /**
     * EventStateChange
     * @description API representation of the EventStateChange resource.
     */
    EventStateChange: {
      /** Esc Type */
      esc_type: string;
      /** Narrative Event Id */
      narrative_event_id: string;
      /** Timeline Event Id */
      timeline_event_id: string;
      event_type: components["schemas"]["NarrativeEventType"];
      /** Thread Id */
      thread_id?: string;
      /** Beat Id */
      beat_id?: string;
      /** Available Step Index */
      available_step_index: number;
      /** Processed Step Index */
      processed_step_index: number;
      /** Workspace Id */
      workspace_id: string;
      /** Project Id */
      project_id: string;
      /** Timeline Id */
      timeline_id: string;
      /** User Id */
      user_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
    };
    /**
     * GeneralError
     * @description Base serializer class for any errors which can be included in a response. This is
     * used by the Response serializer class.
     *
     * If an error is returned, there should be no data in the response (although we are
     * working on the presumption that metadata may still come back). This is
     * handled in the Response serializer validator.
     */
    GeneralError: {
      /** Detail */
      detail?: string;
      /** Content */
      content?: { [key: string]: unknown }[];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * Meta
     * @description Base serializer class for all metadata which can be included in a response. This is
     * used by the Response serializer class.
     *
     * This design pattern afford us the ability to include any generic meta data within
     * this block. For example achievements completed as a bi-product of another action,
     * or cursor/pagination/count metadata you might expect on a list endpoint.
     */
    Meta: {
      /**
       * Changed Timeline Events
       * @default []
       */
      changed_timeline_events?: components["schemas"]["UserTimelineEvent"][];
      /**
       * Changed Timeline Event States
       * @default []
       */
      changed_timeline_event_states?: components["schemas"]["UserTimelineEventStateChange"][];
      /** @default ONLINE */
      service_status?: components["schemas"]["ServiceStatus"];
    };
    /**
     * NarrativeEventType
     * @description
     *     Type of Narrative Event.
     *
     * @enum {string}
     */
    NarrativeEventType: "SIMPLE" | "ACTIVITY" | "CONSUMABLE";
    /**
     * ProgressEventsRequest
     * @description Deserializer used on the progress events RPC endpoint which invokes the execution
     * of the beat machine.
     *
     * The optional `max_steps` field provides a way for the integration engineer to
     * control this execution context.
     *
     * The optional `pause_at_beats` field provides a way to override the user level
     * `pause_at_beats` configuration.
     */
    ProgressEventsRequest: {
      /**
       * Max Steps
       * @description The maximum amount of steps that should be progressed
       * @example 1
       */
      max_steps?: number;
      /**
       * Pause At Beats
       * @description Should beat guards be respected when progressing
       * @example true
       */
      pause_at_beats?: boolean;
    };
    /**
     * ServiceStatus
     * @description An enumeration.
     * @enum {string}
     */
    ServiceStatus: "ONLINE" | "MAINTENANCE";
    /**
     * Timeline
     * @description API representation of timeline resource.
     */
    Timeline: {
      /**
       * Id
       * @example 0nfWvgIlDZVk5yndCLKm
       */
      id: string;
      /**
       * Title
       * @example Alice's Adventure In Wonderland
       */
      title: string;
      /**
       * Description
       * @example A 30 day immersive experience in Wonderland.
       */
      description?: string;
    };
    /**
     * TimelineEvent
     * @description
     */
    TimelineEvent: {
      /**
       * Id
       * @example kNSI3QNGVj3OwByy43ze
       */
      id: string;
      /**
       * Title
       * @example Find the flag!
       */
      title: string;
      /**
       * Description
       * @example You have 30 seconds to find the flag - go go go!
       */
      description?: string;
      /** @example ACTIVITY */
      type: components["schemas"]["NarrativeEventType"];
      /**
       * Step
       * @example 1
       */
      step?: number;
      /**
       * Content Integrations
       * @example {
       *   "AVAILABLE": [
       *     {
       *       "content_id": {
       *         "example": "MN7S90NBDJ"
       *       },
       *       "content_type": {
       *         "example": "BlogPost"
       *       },
       *       "provider_id": {
       *         "example": "Contentful"
       *       }
       *     }
       *   ]
       * }
       */
      content_integrations: {
        [key: string]: components["schemas"]["ContentIntegration"][];
      };
      /** Narrative Event Id */
      narrative_event_id: string;
      /**
       * Narrative Event Custom Data
       * @default {}
       */
      narrative_event_custom_data?: { [key: string]: string };
    };
    /**
     * TokenIntrospectRequest
     * @description Instead of our serializer level objects inheriting from BaseModel, they
     * should all inherit from BaseSerializer, which removes the burden of handling the
     * lookup of a entity key identifiers within our API view logic.
     *
     * By enabling ORM_MODE we can pass in schema objects, and Pydantic will do a
     * __getattr__ style lookup, which will auto unpack the primary key from our
     * BaseSchema inherited object.
     *
     * We also have a thin wrapper around the __init__, which helps to provide a nicer API
     * when unpacking the results of projection queries into our resource serializers. This
     * can be used in conjunction with the `get_projection_properties` helper to get all
     * entity property names from the datastore index.
     */
    TokenIntrospectRequest: {
      /**
       * Access Token
       * @description Access Token to introspect
       * @example ryJhbGciOiJSUzI1NiIsImtpZCI6IjQ7OTQ5ZDdkNDA3ZmVjOXIyYWM4ZDYzNWVjYmEwYjdhOTE0LWQ4ZmIiLCJ0eXAiOiJK
       */
      access_token: string;
    };
    /**
     * TokenIntrospectResponse
     * @description Read only representation of the meta data around an access token.
     */
    TokenIntrospectResponse: {
      /**
       * Is Active
       * @description Status of the token.
       */
      is_active: boolean;
      /**
       * User Id
       * @example 4L9MN83KOS
       */
      user_id?: string;
      /**
       * Expires In
       * @description Time in seconds until the access token expires.
       * @example 3600
       */
      expires_in?: number;
    };
    /**
     * TokenRequest
     * @description
     */
    TokenRequest: {
      /**
       * User Identifier
       * @description User ID scoped to the Access Token being generated.
       * @example 4L9MN83KOS
       */
      user_id: string;
    };
    /**
     * TokenResponse
     * @description Instead of our serializer level objects inheriting from BaseModel, they
     * should all inherit from BaseSerializer, which removes the burden of handling the
     * lookup of a entity key identifiers within our API view logic.
     *
     * By enabling ORM_MODE we can pass in schema objects, and Pydantic will do a
     * __getattr__ style lookup, which will auto unpack the primary key from our
     * BaseSchema inherited object.
     *
     * We also have a thin wrapper around the __init__, which helps to provide a nicer API
     * when unpacking the results of projection queries into our resource serializers. This
     * can be used in conjunction with the `get_projection_properties` helper to get all
     * entity property names from the datastore index.
     */
    TokenResponse: {
      /**
       * Primary Key
       * @description Access Token used to authenticate with Audience APIs.
       * @example ryJhbGciOiJSUzI1NiIsImtpZCI6IjQ7OTQ5ZDdkNDA3ZmVjOXIyYWM4ZDYzNWVjYmEwYjdhOTE0LWQ4ZmIiLCJ0eXAiOiJK
       */
      access_token: string;
      /**
       * Expires In
       * @description Time in seconds until the ID Token expires.
       * @example 3600
       */
      expires_in: number;
    };
    /**
     * User
     * @description Representation of a user - including a mix of their authentication and experience
     * based properties. This should be considered a read-only serializer.
     */
    User: {
      /**
       * Identifier
       * @description Unique identifier for the user.
       * @example 0HJviYCWMZVYowT7ujWtb7rUEpE3
       */
      id: string;
      /** Embedded representation of user story state. */
      narrative_state?: components["schemas"]["UserStoryState"] | null;
    };
    /**
     * UserInvokedTimelineEventState
     * @description
     *     All states a User can update a UserTimelineEvent state value to over API.
     *
     * @enum {string}
     */
    UserInvokedTimelineEventState:
      | "AVAILABLE"
      | "STARTED"
      | "CANCELLED"
      | "COMPLETED"
      | "SKIPPED"
      | "CONSUMED";
    /**
     * UserResponse
     * @description Base serializer class for all responses.
     */
    UserResponse: {
      data?: components["schemas"]["User"];
      /** Error */
      error?: components["schemas"]["GeneralError"] | null;
      /** Meta */
      meta?: components["schemas"]["Meta"] | null;
    };
    /**
     * UserStoryState
     * @description Contains information an integrating client can leverage to elegantly represent and
     * progress the user narrative.
     */
    UserStoryState: {
      /**
       * Current Step
       * @description Current step index for user in event delivery sequence
       */
      current_step?: number;
      /**
       * Current Beat
       * @description Current beat based on user narrative progress.
       */
      current_beat?: components["schemas"]["Beat"] | null;
      /**
       * New Beat Available
       * @description Denotes if the next beat is available for progression.
       * @example {
       *   "id": "PYztAWXDPnz4BM6qDzx4",
       *   "name": "Act 1 Beat 4"
       * }
       */
      new_beat_available?: components["schemas"]["Beat"] | null;
      /**
       * Waiting For Condition Id
       * @description Condition currently blocking further progression
       * @example SzamHkfkMHWpaOUqWOy6
       */
      waiting_for_condition_id?: string;
      /**
       * End Of Timeline Reached
       * @description Denotes if all progression conditions have been satisfied. Note this does not mean that all delivery conditions (on threads for example) have been satisfied.
       */
      end_of_timeline_reached: boolean;
      /**
       * Current Timeline Event Id
       * @description Contains the ID of the current timeline event if the user position is being stored by patching the user-story-state endpoint.
       * @example A4G1fHGkkBZb6HLUc26s
       */
      current_timeline_event_id?: string;
      /**
       * Timeline Event Id History
       * @description History of all the `current_timeline_event_id` values, limited to the most recent 200 event IDs.
       * @default []
       * @example [
       *   "A4G1fHGkkBZb6HLUc26s",
       *   "SzamHkfkMHWpaOUqWOy6"
       * ]
       */
      timeline_event_id_history?: string[];
      /**
       * Datetime Guards Disabled
       * @description Testing feature which skips any time guards if enabled.
       * @example false
       */
      datetime_guards_disabled: boolean;
      /**
       * Pause At Beats
       * @description Should progression execution pause at beats.
       * @example false
       */
      pause_at_beats: boolean;
      /**
       * Active Timeline Id
       * @example nevLb8KWPejFV0t0dy9L
       */
      active_timeline_id: string;
    };
    /**
     * UserStoryStateRequest
     * @description Deserializer used to update a user's current timeline event ID.
     */
    UserStoryStateRequest: {
      /**
       * Current Timeline Event Id
       * @description The new event ID to move the user to.
       * @example nevLb8KWPejFV0t0dy9L
       */
      current_timeline_event_id: string;
    };
    /**
     * UserStoryStateResponse
     * @description Base serializer class for all responses.
     */
    UserStoryStateResponse: {
      data?: components["schemas"]["UserStoryState"];
      /** Error */
      error?: components["schemas"]["GeneralError"] | null;
      /** Meta */
      meta?: components["schemas"]["Meta"] | null;
    };
    /**
     * UserTimelineEvent
     * @description Represents a user timeline event.
     */
    UserTimelineEvent: {
      /**
       * Id
       * @example kNSI3QNGVj3OwByy43ze
       */
      id: string;
      /**
       * Thread Id
       * @example PYztAWXDPnz4BM6qDzx4
       */
      thread_id?: string;
      /**
       * Row Id
       * @example 7D83C0It0Kpm62ZQ1gt9
       */
      row_id: string;
      /**
       * Row Name
       * @example My row title
       */
      row_name: string;
      /**
       * Row Description
       * @example My row description
       */
      row_description?: string;
      /**
       * Previous In Row Timeline Event Id
       * @example IM50smQ3suY3nGOXNjp4
       */
      previous_in_row_timeline_event_id?: string;
      /**
       * Next In Row Timeline Event Id
       * @example s1sad1DkWZephtcJDmtM
       */
      next_in_row_timeline_event_id?: string;
      /**
       * Related Timeline Event Ids
       * @example [
       *   "MN7S90NBDJNSJS"
       * ]
       */
      related_timeline_event_ids: string[];
      /**
       * Available Step Index
       * @description Identifies the step index in which this event becomes available.
       * @example 1
       */
      available_step_index: number;
      /**
       * Available Beat
       * @description Identifies the beat in which this event becomes available.
       */
      available_beat?: components["schemas"]["Beat"];
      /** @example AVAILABLE */
      state: components["schemas"]["UserTimelineEventState"];
      /**
       * @description Future states which can be mutated by the user over API.
       * @example [
       *   "STARTED",
       *   "SKIPPED",
       *   "COMPLETED"
       * ]
       */
      available_states: components["schemas"]["UserInvokedTimelineEventState"][];
      /**
       * Narrative Event Id
       * @example 0nfWvgIlDZVk5yndCLKm
       */
      narrative_event_id: string;
      /** @example ACTIVITY */
      narrative_event_type: components["schemas"]["NarrativeEventType"];
      /**
       * Narrative Event Title
       * @example My narrative event
       */
      narrative_event_title?: string;
      /**
       * Narrative Event Description
       * @example My narrative event description
       */
      narrative_event_description?: string;
      /**
       * Narrative Event Content
       * @example [
       *   {
       *     "content_id": "MN7S90NBDJ",
       *     "content_type": "BlogPost",
       *     "provider_id": "Contentful"
       *   },
       *   {
       *     "content_id": "EL4S90NNDL",
       *     "content_type": "BlogPost",
       *     "provider_id": "Contentful"
       *   }
       * ]
       */
      narrative_event_content: components["schemas"]["ContentIntegration"][];
      /**
       * Narrative Event State Changes Content
       * @description State change content associated with this event.
       * @example {
       *   "AVAILABLE": [
       *     {
       *       "content_id": "MN7S90NBDJ",
       *       "content_type": "BlogPost",
       *       "provider_id": "Contentful"
       *     },
       *     {
       *       "content_id": "EL4S90NNDL",
       *       "content_type": "BlogPost",
       *       "provider_id": "Contentful"
       *     }
       *   ],
       *   "STARTED": [
       *     {
       *       "content_id": "MN7S90NBDJ",
       *       "content_type": "BlogPost",
       *       "provider_id": "Contentful"
       *     }
       *   ]
       * }
       */
      narrative_event_state_changes_content: {
        [key: string]: components["schemas"]["ContentIntegration"][];
      };
      /**
       * Narrative Event Custom Data
       * @default {}
       * @example {
       *   "button_text": "Press me"
       * }
       */
      narrative_event_custom_data?: { [key: string]: string };
    };
    /**
     * UserTimelineEventDetailResponse
     * @description Base serializer class for all responses.
     */
    UserTimelineEventDetailResponse: {
      data?: components["schemas"]["UserTimelineEvent"];
      /** Error */
      error?: components["schemas"]["GeneralError"] | null;
      /** Meta */
      meta?: components["schemas"]["Meta"] | null;
    };

    /**
     * UserTimelineEventListResponse
     * @description Base serializer class for all list responses, inheriting error and metadata from
     * Response serializer.
     */
    UserTimelineEventListResponse: {
      /** Data */
      data?: components["schemas"]["UserTimelineEvent"][];
      /** Error */
      error?: components["schemas"]["GeneralError"] | null;
      /** Meta */
      meta?: components["schemas"]["Meta"] | null;
    };
    /**
     * UserTimelineEventRequest
     * @description Update the `state` of a user timeline event via command.
     */
    UserTimelineEventRequest: {
      state: components["schemas"]["UserInvokedTimelineEventState"];
    };
    /**
     * UserTimelineEventState
     * @description
     *     All states UserTimelineEvent entities can be in.
     *
     * @enum {string}
     */
    UserTimelineEventState:
      | "INITIAL"
      | "AVAILABLE"
      | "STARTED"
      | "COMPLETED"
      | "SKIPPED"
      | "REMOVED"
      | "UNAVAILABLE"
      | "PURGED"
      | "CONSUMED";
    /**
     * UserTimelineEventStateChange
     * @description Represents a user timeline event state change.
     */
    UserTimelineEventStateChange: {
      /** @example STARTED */
      state: components["schemas"]["UserTimelineEventState"];
      /**
       * State Changed At
       * Format: date-time
       */
      state_changed_at?: string;
      /**
       * State Change Content
       * @example [
       *   {
       *     "content_id": "MN7S90NBDJ",
       *     "content_type": "BlogPost",
       *     "provider_id": "Contentful"
       *   },
       *   {
       *     "content_id": "EL4S90NNDL",
       *     "content_type": "BlogPost",
       *     "provider_id": "Contentful"
       *   }
       * ]
       */
      state_change_content: components["schemas"]["ContentIntegration"][];
      /**
       * Timeline Event Id
       * @example PYztAWXDPnz4BM6qDzx4
       */
      timeline_event_id: string;
      /**
       * Thread Id
       * @example 7D83C0It0Kpm62ZQ1gt9
       */
      thread_id?: string;
      /**
       * Row Id
       * @example i55GFxgI3AODsW9OacUz
       */
      row_id: string;
      /** Row Name */
      row_name: string;
      /**
       * Narrative Event Id
       * @example 0nfWvgIlDZVk5yndCLKm
       */
      narrative_event_id: string;
      /** @example ACTIVITY */
      narrative_event_type: components["schemas"]["NarrativeEventType"];
      /**
       * Narrative Event Title
       * @example My narrative event
       */
      narrative_event_title?: string;
      /**
       * Narrative Event Description
       * @example My narrative event description
       */
      narrative_event_description?: string;
    };
    /**
     * UserTimelineEventStateChangeListResponse
     * @description Base serializer class for all list responses, inheriting error and metadata from
     * Response serializer.
     */
    UserTimelineEventStateChangeListResponse: {
      /** Data */
      data?: components["schemas"]["UserTimelineEventStateChange"][];
      /** Error */
      error?: components["schemas"]["GeneralError"] | null;
      /** Meta */
      meta?: components["schemas"]["Meta"] | null;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (Partial<string> & Partial<number>)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
}

export interface operations {
  /**
   * Generate a new Access Token which can be used to authenticate against
   * the Audience API.
   *
   * An API key is required in the HTTP Authorization header.
   */
  generate_tokens_v1_auth_token_post: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TokenResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenRequest"];
      };
    };
  };
  /**
   * Inspect an Access token generated by the Fictioneers Authorization service.
   *
   * Requires a secret API Key in the HTTP Authorization header.
   */
  token_info_v1_auth_introspect_token_post: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TokenIntrospectResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenIntrospectRequest"];
      };
    };
  };
  /** Retrieve detailed representation of the current user (and user story state). */
  get_user_me_v1_users_me_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /** Delete the user and any user associated objects from the current timeline. */
  delete_user_v1_users_me_delete: {
    responses: {
      /** Successful Response */
      204: never;
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /** Create a new audience user for a Fictioneers powered experience. */
  create_user_v1_users_post: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserRequest"];
      };
    };
  };
  /** Representation of authenticated users narrative story state. */
  get_user_story_state_v1_user_story_state_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserStoryStateResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Updates the current timeline event ID for the user, adding the previous value to
   * the history.
   */
  patch_user_story_state_v1_user_story_state_patch: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserStoryStateResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserStoryStateRequest"];
      };
    };
  };
  /** Progress events based on the authenticated user available transition events. */
  step_events_for_user_via_post_v1_user_story_state_progress_events_post: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserStoryStateResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** Service Unavailable - Potentially due to contention. */
      503: {
        content: {
          "application/json": unknown;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProgressEventsRequest"];
      };
    };
  };
  /**
   * List endpoint for user timeline events ordered by step index (including events
   * in an INITIAL state).
   */
  list_timeline_events_for_user_v1_user_timeline_events_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserTimelineEventListResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /** Patch endpoint for user timeline events. */
  update_user_timeline_event_v1_user_timeline_events__timeline_event_id__patch: {
    parameters: {
      path: {
        timeline_event_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserTimelineEventDetailResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** Service Unavailable - Potentially due to contention. */
      503: {
        content: {
          "application/json": unknown;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserTimelineEventRequest"];
      };
    };
  };
  /**
   * List endpoint for user timeline event state changes implicitly filtered by the
   * authenticated user ID.
   */
  get_user_timeline_event_state_changes_v1_user_timeline_event_state_changes_get: {
    parameters: {
      query: {
        content_type?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserTimelineEventStateChangeListResponse"];
        };
      };
      /** Authentication Required */
      401: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: {
        content: {
          "application/json": unknown;
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List all published timelines which users can be placed on. */
  get_timelines_v1_timelines_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Timeline"][];
        };
      };
    };
  };
  /** Representation of a single timeline. */
  get_timeline_v1_timelines__timeline_id__get: {
    parameters: {
      path: {
        timeline_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Timeline"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Lists all timeline events on a specific timeline. */
  list_timeline_timeline_events_v1_timelines__timeline_id__timeline_events_get: {
    parameters: {
      path: {
        timeline_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TimelineEvent"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List of all users on timeline. */
  get_timeline_users_v1_timelines__timeline_id__users_get: {
    parameters: {
      path: {
        timeline_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["User"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete all users on a timeline. */
  delete_all_timeline_users_v1_timelines__timeline_id__users_delete: {
    parameters: {
      path: {
        timeline_id: string;
      };
    };
    responses: {
      /** Successful Response */
      204: never;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Retrieves timeline user. */
  get_timeline_user_v1_timelines__timeline_id__users__user_id__get: {
    parameters: {
      path: {
        timeline_id: string;
        user_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete timeline user. */
  delete_timeline_user_v1_timelines__timeline_id__users__user_id__delete: {
    parameters: {
      path: {
        timeline_id: string;
        user_id: string;
      };
    };
    responses: {
      /** Successful Response */
      204: never;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Returns all event state changes filtered by timeline. */
  list_all_timeline_event_state_changes_v1_timelines__timeline_id__event_state_changes_get: {
    parameters: {
      path: {
        timeline_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EventStateChange"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}

export interface external {}
