/* tslint:disable */
/* eslint-disable */
/**
 * Fictioneers - Audience APIs.
 * JSON APIs used to integrate with the Fictioneers platform served from https://api.fictioneers.co.uk
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Identifies the beat in which this event becomes available.
 * @export
 * @interface AvailableBeat
 */
export interface AvailableBeat {
    /**
     * ID of the beat.
     * @type {string}
     * @memberof AvailableBeat
     */
    'id'?: string;
    /**
     * Name of the beat.
     * @type {string}
     * @memberof AvailableBeat
     */
    'name'?: string;
}
/**
 * Represents a beat object on a narrative timeline.
 * @export
 * @interface Beat
 */
export interface Beat {
    /**
     * ID of the beat.
     * @type {string}
     * @memberof Beat
     */
    'id'?: string;
    /**
     * Name of the beat.
     * @type {string}
     * @memberof Beat
     */
    'name'?: string;
}
/**
 * Represents content referenced in an external data source to an event state.
 * @export
 * @interface ContentIntegration
 */
export interface ContentIntegration {
    /**
     * 
     * @type {string}
     * @memberof ContentIntegration
     */
    'content_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContentIntegration
     */
    'content_type': string;
    /**
     * 
     * @type {string}
     * @memberof ContentIntegration
     */
    'provider_id': string;
}
/**
 * Used when creating a new user entity.  The timeline ID and timezone is explicitly provided by the client - while the user email address and other mandatory fields are extracted from the verified JWT token sent in the authorization header.
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'published_timeline_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'timezone': string;
    /**
     * Feature flag to bypass time based guards per user.
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'disable_time_guards'?: boolean;
    /**
     * Feature flag to toggle pausing execution of progression at beat markers.
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'pause_at_beats'?: boolean;
}
/**
 * Current beat based on user narrative progress.
 * @export
 * @interface CurrentBeat
 */
export interface CurrentBeat {
    /**
     * ID of the beat.
     * @type {string}
     * @memberof CurrentBeat
     */
    'id'?: string;
    /**
     * Name of the beat.
     * @type {string}
     * @memberof CurrentBeat
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedRepresentationOfUserStoryState
 */
export interface EmbeddedRepresentationOfUserStoryState {
    /**
     * Current step index for user in event delivery sequence
     * @type {number}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'current_step'?: number;
    /**
     * 
     * @type {CurrentBeat}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'current_beat'?: CurrentBeat | null;
    /**
     * 
     * @type {NewBeatAvailable}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'new_beat_available'?: NewBeatAvailable | null;
    /**
     * Condition currently blocking further progression
     * @type {string}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'waiting_for_condition_id'?: string;
    /**
     * Denotes if all progression conditions have been satisfied. Note this does not mean that all delivery conditions (on threads for example) have been satisfied.
     * @type {boolean}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'end_of_timeline_reached': boolean;
    /**
     * Contains the ID of the current timeline event if the user position is being stored by patching the user-story-state endpoint.
     * @type {string}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'current_timeline_event_id'?: string;
    /**
     * History of all the `current_timeline_event_id` values, limited to the most recent 200 event IDs.
     * @type {Array<string>}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'timeline_event_id_history'?: Array<string>;
    /**
     * Testing feature which skips any time guards if enabled.
     * @type {boolean}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'datetime_guards_disabled': boolean;
    /**
     * Should progression execution pause at beats.
     * @type {boolean}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'pause_at_beats': boolean;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedRepresentationOfUserStoryState
     */
    'active_timeline_id': string;
}
/**
 * API representation of the EventStateChange resource.
 * @export
 * @interface EventStateChange
 */
export interface EventStateChange {
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'esc_type': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'narrative_event_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'timeline_event_id': string;
    /**
     * 
     * @type {NarrativeEventType}
     * @memberof EventStateChange
     */
    'event_type': NarrativeEventType;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'thread_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'beat_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventStateChange
     */
    'available_step_index': number;
    /**
     * 
     * @type {number}
     * @memberof EventStateChange
     */
    'processed_step_index': number;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'workspace_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'timeline_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventStateChange
     */
    'created_at': string;
}
/**
 * Base serializer class for any errors which can be included in a response. This is used by the Response serializer class.  If an error is returned, there should be no data in the response (although we are working on the presumption that metadata may still come back). This is handled in the Response serializer validator.
 * @export
 * @interface GeneralError
 */
export interface GeneralError {
    /**
     * 
     * @type {string}
     * @memberof GeneralError
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof GeneralError
     */
    'content'?: Array<object>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * Base serializer class for all metadata which can be included in a response. This is used by the Response serializer class.  This design pattern afford us the ability to include any generic meta data within this block. For example achievements completed as a bi-product of another action, or cursor/pagination/count metadata you might expect on a list endpoint.
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {Array<UserTimelineEvent>}
     * @memberof Meta
     */
    'changed_timeline_events'?: Array<UserTimelineEvent>;
    /**
     * 
     * @type {Array<UserTimelineEventStateChange>}
     * @memberof Meta
     */
    'changed_timeline_event_states'?: Array<UserTimelineEventStateChange>;
    /**
     * 
     * @type {ServiceStatus}
     * @memberof Meta
     */
    'service_status'?: ServiceStatus;
}
/**
 * 
 * @export
 * @interface Meta1
 */
export interface Meta1 {
    /**
     * 
     * @type {Array<UserTimelineEvent>}
     * @memberof Meta1
     */
    'changed_timeline_events'?: Array<UserTimelineEvent>;
    /**
     * 
     * @type {Array<UserTimelineEventStateChange>}
     * @memberof Meta1
     */
    'changed_timeline_event_states'?: Array<UserTimelineEventStateChange>;
    /**
     * 
     * @type {ServiceStatus}
     * @memberof Meta1
     */
    'service_status'?: ServiceStatus;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ModelError
     */
    'content'?: Array<object>;
}
/**
 * Type of Narrative Event.
 * @export
 * @enum {string}
 */

export const NarrativeEventType = {
    Simple: 'SIMPLE',
    Activity: 'ACTIVITY',
    Consumable: 'CONSUMABLE'
} as const;

export type NarrativeEventType = typeof NarrativeEventType[keyof typeof NarrativeEventType];


/**
 * Denotes if the next beat is available for progression.
 * @export
 * @interface NewBeatAvailable
 */
export interface NewBeatAvailable {
    /**
     * ID of the beat.
     * @type {string}
     * @memberof NewBeatAvailable
     */
    'id'?: string;
    /**
     * Name of the beat.
     * @type {string}
     * @memberof NewBeatAvailable
     */
    'name'?: string;
}
/**
 * Deserializer used on the progress events RPC endpoint which invokes the execution of the beat machine.  The optional `max_steps` field provides a way for the integration engineer to control this execution context.  The optional `pause_at_beats` field provides a way to override the user level `pause_at_beats` configuration.
 * @export
 * @interface ProgressEventsRequest
 */
export interface ProgressEventsRequest {
    /**
     * The maximum amount of steps that should be progressed
     * @type {number}
     * @memberof ProgressEventsRequest
     */
    'max_steps'?: number;
    /**
     * Should beat guards be respected when progressing
     * @type {boolean}
     * @memberof ProgressEventsRequest
     */
    'pause_at_beats'?: boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ServiceStatus = {
    Online: 'ONLINE',
    Maintenance: 'MAINTENANCE'
} as const;

export type ServiceStatus = typeof ServiceStatus[keyof typeof ServiceStatus];


/**
 * API representation of timeline resource.
 * @export
 * @interface Timeline
 */
export interface Timeline {
    /**
     * 
     * @type {string}
     * @memberof Timeline
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Timeline
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Timeline
     */
    'description'?: string;
}
/**
 *     
 * @export
 * @interface TimelineEvent
 */
export interface TimelineEvent {
    /**
     * 
     * @type {string}
     * @memberof TimelineEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TimelineEvent
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TimelineEvent
     */
    'description'?: string;
    /**
     * 
     * @type {NarrativeEventType}
     * @memberof TimelineEvent
     */
    'type': NarrativeEventType;
    /**
     * 
     * @type {number}
     * @memberof TimelineEvent
     */
    'step'?: number;
    /**
     * 
     * @type {{ [key: string]: Array<ContentIntegration>; }}
     * @memberof TimelineEvent
     */
    'content_integrations': { [key: string]: Array<ContentIntegration>; };
    /**
     * 
     * @type {string}
     * @memberof TimelineEvent
     */
    'narrative_event_id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TimelineEvent
     */
    'narrative_event_custom_data'?: { [key: string]: string; };
}
/**
 * Instead of our serializer level objects inheriting from BaseModel, they should all inherit from BaseSerializer, which removes the burden of handling the lookup of a entity key identifiers within our API view logic.  By enabling ORM_MODE we can pass in schema objects, and Pydantic will do a __getattr__ style lookup, which will auto unpack the primary key from our BaseSchema inherited object.  We also have a thin wrapper around the __init__, which helps to provide a nicer API when unpacking the results of projection queries into our resource serializers. This can be used in conjunction with the `get_projection_properties` helper to get all entity property names from the datastore index.
 * @export
 * @interface TokenIntrospectRequest
 */
export interface TokenIntrospectRequest {
    /**
     * Access Token to introspect
     * @type {string}
     * @memberof TokenIntrospectRequest
     */
    'access_token': string;
}
/**
 * Read only representation of the meta data around an access token.
 * @export
 * @interface TokenIntrospectResponse
 */
export interface TokenIntrospectResponse {
    /**
     * Status of the token.
     * @type {boolean}
     * @memberof TokenIntrospectResponse
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenIntrospectResponse
     */
    'user_id'?: string;
    /**
     * Time in seconds until the access token expires.
     * @type {number}
     * @memberof TokenIntrospectResponse
     */
    'expires_in'?: number;
}
/**
 *     
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * User ID scoped to the Access Token being generated.
     * @type {string}
     * @memberof TokenRequest
     */
    'user_id': string;
}
/**
 * Instead of our serializer level objects inheriting from BaseModel, they should all inherit from BaseSerializer, which removes the burden of handling the lookup of a entity key identifiers within our API view logic.  By enabling ORM_MODE we can pass in schema objects, and Pydantic will do a __getattr__ style lookup, which will auto unpack the primary key from our BaseSchema inherited object.  We also have a thin wrapper around the __init__, which helps to provide a nicer API when unpacking the results of projection queries into our resource serializers. This can be used in conjunction with the `get_projection_properties` helper to get all entity property names from the datastore index.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * Access Token used to authenticate with Audience APIs.
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * Time in seconds until the ID Token expires.
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
}
/**
 * Representation of a user - including a mix of their authentication and experience based properties. This should be considered a read-only serializer.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the user.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {EmbeddedRepresentationOfUserStoryState}
     * @memberof User
     */
    'narrative_state'?: EmbeddedRepresentationOfUserStoryState | null;
}
/**
 * All states a User can update a UserTimelineEvent state value to over API.
 * @export
 * @enum {string}
 */

export const UserInvokedTimelineEventState = {
    Available: 'AVAILABLE',
    Started: 'STARTED',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Skipped: 'SKIPPED',
    Consumed: 'CONSUMED'
} as const;

export type UserInvokedTimelineEventState = typeof UserInvokedTimelineEventState[keyof typeof UserInvokedTimelineEventState];


/**
 * Base serializer class for all responses.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    'data'?: User;
    /**
     * 
     * @type {Error}
     * @memberof UserResponse
     */
    'error'?: Error | null;
    /**
     * 
     * @type {Meta1}
     * @memberof UserResponse
     */
    'meta'?: Meta1 | null;
}
/**
 * Contains information an integrating client can leverage to elegantly represent and progress the user narrative.
 * @export
 * @interface UserStoryState
 */
export interface UserStoryState {
    /**
     * Current step index for user in event delivery sequence
     * @type {number}
     * @memberof UserStoryState
     */
    'current_step'?: number;
    /**
     * 
     * @type {CurrentBeat}
     * @memberof UserStoryState
     */
    'current_beat'?: CurrentBeat | null;
    /**
     * 
     * @type {NewBeatAvailable}
     * @memberof UserStoryState
     */
    'new_beat_available'?: NewBeatAvailable | null;
    /**
     * Condition currently blocking further progression
     * @type {string}
     * @memberof UserStoryState
     */
    'waiting_for_condition_id'?: string;
    /**
     * Denotes if all progression conditions have been satisfied. Note this does not mean that all delivery conditions (on threads for example) have been satisfied.
     * @type {boolean}
     * @memberof UserStoryState
     */
    'end_of_timeline_reached': boolean;
    /**
     * Contains the ID of the current timeline event if the user position is being stored by patching the user-story-state endpoint.
     * @type {string}
     * @memberof UserStoryState
     */
    'current_timeline_event_id'?: string;
    /**
     * History of all the `current_timeline_event_id` values, limited to the most recent 200 event IDs.
     * @type {Array<string>}
     * @memberof UserStoryState
     */
    'timeline_event_id_history'?: Array<string>;
    /**
     * Testing feature which skips any time guards if enabled.
     * @type {boolean}
     * @memberof UserStoryState
     */
    'datetime_guards_disabled': boolean;
    /**
     * Should progression execution pause at beats.
     * @type {boolean}
     * @memberof UserStoryState
     */
    'pause_at_beats': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserStoryState
     */
    'active_timeline_id': string;
}
/**
 * Deserializer used to update a user\'s current timeline event ID.
 * @export
 * @interface UserStoryStateRequest
 */
export interface UserStoryStateRequest {
    /**
     * The new event ID to move the user to.
     * @type {string}
     * @memberof UserStoryStateRequest
     */
    'current_timeline_event_id': string;
}
/**
 * Base serializer class for all responses.
 * @export
 * @interface UserStoryStateResponse
 */
export interface UserStoryStateResponse {
    /**
     * 
     * @type {UserStoryState}
     * @memberof UserStoryStateResponse
     */
    'data'?: UserStoryState;
    /**
     * 
     * @type {Error}
     * @memberof UserStoryStateResponse
     */
    'error'?: Error | null;
    /**
     * 
     * @type {Meta1}
     * @memberof UserStoryStateResponse
     */
    'meta'?: Meta1 | null;
}
/**
 * Represents a user timeline event.
 * @export
 * @interface UserTimelineEvent
 */
export interface UserTimelineEvent {
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'thread_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'row_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'row_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'previous_in_row_timeline_event_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'next_in_row_timeline_event_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserTimelineEvent
     */
    'related_timeline_event_ids': Array<string>;
    /**
     * Identifies the step index in which this event becomes available.
     * @type {number}
     * @memberof UserTimelineEvent
     */
    'available_step_index': number;
    /**
     * 
     * @type {AvailableBeat}
     * @memberof UserTimelineEvent
     */
    'available_beat'?: AvailableBeat;
    /**
     * 
     * @type {UserTimelineEventState}
     * @memberof UserTimelineEvent
     */
    'state': UserTimelineEventState;
    /**
     * Future states which can be mutated by the user over API.
     * @type {Array<UserInvokedTimelineEventState>}
     * @memberof UserTimelineEvent
     */
    'available_states': Array<UserInvokedTimelineEventState>;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'narrative_event_id': string;
    /**
     * 
     * @type {NarrativeEventType}
     * @memberof UserTimelineEvent
     */
    'narrative_event_type': NarrativeEventType;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'narrative_event_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEvent
     */
    'narrative_event_description'?: string;
    /**
     * 
     * @type {Array<ContentIntegration>}
     * @memberof UserTimelineEvent
     */
    'narrative_event_content': Array<ContentIntegration>;
    /**
     * State change content associated with this event.
     * @type {{ [key: string]: Array<ContentIntegration>; }}
     * @memberof UserTimelineEvent
     */
    'narrative_event_state_changes_content': { [key: string]: Array<ContentIntegration>; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserTimelineEvent
     */
    'narrative_event_custom_data'?: { [key: string]: string; };
}
/**
 * Base serializer class for all responses.
 * @export
 * @interface UserTimelineEventDetailResponse
 */
export interface UserTimelineEventDetailResponse {
    /**
     * 
     * @type {UserTimelineEvent}
     * @memberof UserTimelineEventDetailResponse
     */
    'data'?: UserTimelineEvent;
    /**
     * 
     * @type {Error}
     * @memberof UserTimelineEventDetailResponse
     */
    'error'?: Error | null;
    /**
     * 
     * @type {Meta1}
     * @memberof UserTimelineEventDetailResponse
     */
    'meta'?: Meta1 | null;
}
/**
 * Base serializer class for all list responses, inheriting error and metadata from Response serializer.
 * @export
 * @interface UserTimelineEventListResponse
 */
export interface UserTimelineEventListResponse {
    /**
     * 
     * @type {Array<UserTimelineEvent>}
     * @memberof UserTimelineEventListResponse
     */
    'data'?: Array<UserTimelineEvent>;
    /**
     * 
     * @type {Error}
     * @memberof UserTimelineEventListResponse
     */
    'error'?: Error | null;
    /**
     * 
     * @type {Meta1}
     * @memberof UserTimelineEventListResponse
     */
    'meta'?: Meta1 | null;
}
/**
 * Update the `state` of a user timeline event via command.
 * @export
 * @interface UserTimelineEventRequest
 */
export interface UserTimelineEventRequest {
    /**
     * 
     * @type {UserInvokedTimelineEventState}
     * @memberof UserTimelineEventRequest
     */
    'state': UserInvokedTimelineEventState;
}
/**
 * All states UserTimelineEvent entities can be in.
 * @export
 * @enum {string}
 */

export const UserTimelineEventState = {
    Initial: 'INITIAL',
    Available: 'AVAILABLE',
    Started: 'STARTED',
    Completed: 'COMPLETED',
    Skipped: 'SKIPPED',
    Removed: 'REMOVED',
    Unavailable: 'UNAVAILABLE',
    Purged: 'PURGED',
    Consumed: 'CONSUMED'
} as const;

export type UserTimelineEventState = typeof UserTimelineEventState[keyof typeof UserTimelineEventState];


/**
 * Represents a user timeline event state change.
 * @export
 * @interface UserTimelineEventStateChange
 */
export interface UserTimelineEventStateChange {
    /**
     * 
     * @type {UserTimelineEventState}
     * @memberof UserTimelineEventStateChange
     */
    'state': UserTimelineEventState;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'state_changed_at'?: string;
    /**
     * 
     * @type {Array<ContentIntegration>}
     * @memberof UserTimelineEventStateChange
     */
    'state_change_content': Array<ContentIntegration>;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'timeline_event_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'thread_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'row_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'row_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'narrative_event_id': string;
    /**
     * 
     * @type {NarrativeEventType}
     * @memberof UserTimelineEventStateChange
     */
    'narrative_event_type': NarrativeEventType;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'narrative_event_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTimelineEventStateChange
     */
    'narrative_event_description'?: string;
}
/**
 * Base serializer class for all list responses, inheriting error and metadata from Response serializer.
 * @export
 * @interface UserTimelineEventStateChangeListResponse
 */
export interface UserTimelineEventStateChangeListResponse {
    /**
     * 
     * @type {Array<UserTimelineEventStateChange>}
     * @memberof UserTimelineEventStateChangeListResponse
     */
    'data'?: Array<UserTimelineEventStateChange>;
    /**
     * 
     * @type {Error}
     * @memberof UserTimelineEventStateChangeListResponse
     */
    'error'?: Error | null;
    /**
     * 
     * @type {Meta1}
     * @memberof UserTimelineEventStateChangeListResponse
     */
    'meta'?: Meta1 | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all users on a timeline.
         * @summary Delete all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete: async (timelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete', 'timelineId', timelineId)
            const localVarPath = `/v1/timelines/{timeline_id}/users`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete timeline user.
         * @summary Delete timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete: async (timelineId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete', 'timelineId', timelineId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/v1/timelines/{timeline_id}/users/{user_id}`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves timeline user.
         * @summary Retrieves timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineUserV1TimelinesTimelineIdUsersUserIdGet: async (timelineId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('getTimelineUserV1TimelinesTimelineIdUsersUserIdGet', 'timelineId', timelineId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTimelineUserV1TimelinesTimelineIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/v1/timelines/{timeline_id}/users/{user_id}`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all users on timeline.
         * @summary List all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineUsersV1TimelinesTimelineIdUsersGet: async (timelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('getTimelineUsersV1TimelinesTimelineIdUsersGet', 'timelineId', timelineId)
            const localVarPath = `/v1/timelines/{timeline_id}/users`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Representation of a single timeline.
         * @summary Retrieves timeline
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineV1TimelinesTimelineIdGet: async (timelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('getTimelineV1TimelinesTimelineIdGet', 'timelineId', timelineId)
            const localVarPath = `/v1/timelines/{timeline_id}`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all published timelines which users can be placed on.
         * @summary List all published timelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesV1TimelinesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/timelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all event state changes filtered by timeline.
         * @summary List all event state changes for timeline.
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet: async (timelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet', 'timelineId', timelineId)
            const localVarPath = `/v1/timelines/{timeline_id}/event-state-changes`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all timeline events on a specific timeline.
         * @summary Lists all timeline events
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet: async (timelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineId' is not null or undefined
            assertParamExists('listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet', 'timelineId', timelineId)
            const localVarPath = `/v1/timelines/{timeline_id}/timeline-events`
                .replace(`{${"timeline_id"}}`, encodeURIComponent(String(timelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete all users on a timeline.
         * @summary Delete all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete timeline user.
         * @summary Delete timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves timeline user.
         * @summary Retrieves timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of all users on timeline.
         * @summary List all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Representation of a single timeline.
         * @summary Retrieves timeline
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelineV1TimelinesTimelineIdGet(timelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Timeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelineV1TimelinesTimelineIdGet(timelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all published timelines which users can be placed on.
         * @summary List all published timelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelinesV1TimelinesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Timeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelinesV1TimelinesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all event state changes filtered by timeline.
         * @summary List all event state changes for timeline.
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventStateChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all timeline events on a specific timeline.
         * @summary Lists all timeline events
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimelineEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Delete all users on a timeline.
         * @summary Delete all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete timeline user.
         * @summary Delete timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves timeline user.
         * @summary Retrieves timeline user
         * @param {string} timelineId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId: string, userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all users on timeline.
         * @summary List all timeline users
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Representation of a single timeline.
         * @summary Retrieves timeline
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineV1TimelinesTimelineIdGet(timelineId: string, options?: any): AxiosPromise<Timeline> {
            return localVarFp.getTimelineV1TimelinesTimelineIdGet(timelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all published timelines which users can be placed on.
         * @summary List all published timelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesV1TimelinesGet(options?: any): AxiosPromise<Array<Timeline>> {
            return localVarFp.getTimelinesV1TimelinesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all event state changes filtered by timeline.
         * @summary List all event state changes for timeline.
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId: string, options?: any): AxiosPromise<Array<EventStateChange>> {
            return localVarFp.listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all timeline events on a specific timeline.
         * @summary Lists all timeline events
         * @param {string} timelineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId: string, options?: any): AxiosPromise<Array<TimelineEvent>> {
            return localVarFp.listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Delete all users on a timeline.
     * @summary Delete all timeline users
     * @param {string} timelineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteAllTimelineUsersV1TimelinesTimelineIdUsersDelete(timelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete timeline user.
     * @summary Delete timeline user
     * @param {string} timelineId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId: string, userId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteTimelineUserV1TimelinesTimelineIdUsersUserIdDelete(timelineId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves timeline user.
     * @summary Retrieves timeline user
     * @param {string} timelineId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId: string, userId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTimelineUserV1TimelinesTimelineIdUsersUserIdGet(timelineId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all users on timeline.
     * @summary List all timeline users
     * @param {string} timelineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTimelineUsersV1TimelinesTimelineIdUsersGet(timelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Representation of a single timeline.
     * @summary Retrieves timeline
     * @param {string} timelineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTimelineV1TimelinesTimelineIdGet(timelineId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTimelineV1TimelinesTimelineIdGet(timelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all published timelines which users can be placed on.
     * @summary List all published timelines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTimelinesV1TimelinesGet(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTimelinesV1TimelinesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all event state changes filtered by timeline.
     * @summary List all event state changes for timeline.
     * @param {string} timelineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listAllTimelineEventStateChangesV1TimelinesTimelineIdEventStateChangesGet(timelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all timeline events on a specific timeline.
     * @summary Lists all timeline events
     * @param {string} timelineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listTimelineTimelineEventsV1TimelinesTimelineIdTimelineEventsGet(timelineId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a new Access Token which can be used to authenticate against the Audience API.  An API key is required in the HTTP Authorization header.
         * @summary Generate a new Access Token for a user.
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTokensV1AuthTokenPost: async (tokenRequest: TokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('generateTokensV1AuthTokenPost', 'tokenRequest', tokenRequest)
            const localVarPath = `/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect an Access token generated by the Fictioneers Authorization service.  Requires a secret API Key in the HTTP Authorization header. 
         * @summary Introspect an Access Token (development use only).
         * @param {TokenIntrospectRequest} tokenIntrospectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenInfoV1AuthIntrospectTokenPost: async (tokenIntrospectRequest: TokenIntrospectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenIntrospectRequest' is not null or undefined
            assertParamExists('tokenInfoV1AuthIntrospectTokenPost', 'tokenIntrospectRequest', tokenIntrospectRequest)
            const localVarPath = `/v1/auth/introspect-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API Key Header Authentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenIntrospectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a new Access Token which can be used to authenticate against the Audience API.  An API key is required in the HTTP Authorization header.
         * @summary Generate a new Access Token for a user.
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTokensV1AuthTokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTokensV1AuthTokenPost(tokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inspect an Access token generated by the Fictioneers Authorization service.  Requires a secret API Key in the HTTP Authorization header. 
         * @summary Introspect an Access Token (development use only).
         * @param {TokenIntrospectRequest} tokenIntrospectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest: TokenIntrospectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenIntrospectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Generate a new Access Token which can be used to authenticate against the Audience API.  An API key is required in the HTTP Authorization header.
         * @summary Generate a new Access Token for a user.
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTokensV1AuthTokenPost(tokenRequest: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.generateTokensV1AuthTokenPost(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect an Access token generated by the Fictioneers Authorization service.  Requires a secret API Key in the HTTP Authorization header. 
         * @summary Introspect an Access Token (development use only).
         * @param {TokenIntrospectRequest} tokenIntrospectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest: TokenIntrospectRequest, options?: any): AxiosPromise<TokenIntrospectResponse> {
            return localVarFp.tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Generate a new Access Token which can be used to authenticate against the Audience API.  An API key is required in the HTTP Authorization header.
     * @summary Generate a new Access Token for a user.
     * @param {TokenRequest} tokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateTokensV1AuthTokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).generateTokensV1AuthTokenPost(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect an Access token generated by the Fictioneers Authorization service.  Requires a secret API Key in the HTTP Authorization header. 
     * @summary Introspect an Access Token (development use only).
     * @param {TokenIntrospectRequest} tokenIntrospectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest: TokenIntrospectRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).tokenInfoV1AuthIntrospectTokenPost(tokenIntrospectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserStoryStateApi - axios parameter creator
 * @export
 */
export const UserStoryStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Representation of authenticated users narrative story state.
         * @summary Retrieves user narrative state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStoryStateV1UserStoryStateGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user-story-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the current timeline event ID for the user, adding the previous value to the history.
         * @summary Updates the current timeline event ID for the user
         * @param {UserStoryStateRequest} userStoryStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserStoryStateV1UserStoryStatePatch: async (userStoryStateRequest: UserStoryStateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userStoryStateRequest' is not null or undefined
            assertParamExists('patchUserStoryStateV1UserStoryStatePatch', 'userStoryStateRequest', userStoryStateRequest)
            const localVarPath = `/v1/user-story-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userStoryStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Progress events based on the authenticated user available transition events.
         * @summary Progress timeline events
         * @param {ProgressEventsRequest} progressEventsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepEventsForUserViaPostV1UserStoryStateProgressEventsPost: async (progressEventsRequest: ProgressEventsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'progressEventsRequest' is not null or undefined
            assertParamExists('stepEventsForUserViaPostV1UserStoryStateProgressEventsPost', 'progressEventsRequest', progressEventsRequest)
            const localVarPath = `/v1/user-story-state/progress-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(progressEventsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserStoryStateApi - functional programming interface
 * @export
 */
export const UserStoryStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserStoryStateApiAxiosParamCreator(configuration)
    return {
        /**
         * Representation of authenticated users narrative story state.
         * @summary Retrieves user narrative state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStoryStateV1UserStoryStateGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStoryStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStoryStateV1UserStoryStateGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the current timeline event ID for the user, adding the previous value to the history.
         * @summary Updates the current timeline event ID for the user
         * @param {UserStoryStateRequest} userStoryStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest: UserStoryStateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStoryStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Progress events based on the authenticated user available transition events.
         * @summary Progress timeline events
         * @param {ProgressEventsRequest} progressEventsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest: ProgressEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStoryStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserStoryStateApi - factory interface
 * @export
 */
export const UserStoryStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserStoryStateApiFp(configuration)
    return {
        /**
         * Representation of authenticated users narrative story state.
         * @summary Retrieves user narrative state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStoryStateV1UserStoryStateGet(options?: any): AxiosPromise<UserStoryStateResponse> {
            return localVarFp.getUserStoryStateV1UserStoryStateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the current timeline event ID for the user, adding the previous value to the history.
         * @summary Updates the current timeline event ID for the user
         * @param {UserStoryStateRequest} userStoryStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest: UserStoryStateRequest, options?: any): AxiosPromise<UserStoryStateResponse> {
            return localVarFp.patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Progress events based on the authenticated user available transition events.
         * @summary Progress timeline events
         * @param {ProgressEventsRequest} progressEventsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest: ProgressEventsRequest, options?: any): AxiosPromise<UserStoryStateResponse> {
            return localVarFp.stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserStoryStateApi - object-oriented interface
 * @export
 * @class UserStoryStateApi
 * @extends {BaseAPI}
 */
export class UserStoryStateApi extends BaseAPI {
    /**
     * Representation of authenticated users narrative story state.
     * @summary Retrieves user narrative state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStoryStateApi
     */
    public getUserStoryStateV1UserStoryStateGet(options?: AxiosRequestConfig) {
        return UserStoryStateApiFp(this.configuration).getUserStoryStateV1UserStoryStateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the current timeline event ID for the user, adding the previous value to the history.
     * @summary Updates the current timeline event ID for the user
     * @param {UserStoryStateRequest} userStoryStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStoryStateApi
     */
    public patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest: UserStoryStateRequest, options?: AxiosRequestConfig) {
        return UserStoryStateApiFp(this.configuration).patchUserStoryStateV1UserStoryStatePatch(userStoryStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Progress events based on the authenticated user available transition events.
     * @summary Progress timeline events
     * @param {ProgressEventsRequest} progressEventsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStoryStateApi
     */
    public stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest: ProgressEventsRequest, options?: AxiosRequestConfig) {
        return UserStoryStateApiFp(this.configuration).stepEventsForUserViaPostV1UserStoryStateProgressEventsPost(progressEventsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserTimelineEventStateChangesApi - axios parameter creator
 * @export
 */
export const UserTimelineEventStateChangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List endpoint for user timeline event state changes implicitly filtered by the authenticated user ID.
         * @summary Lists all user timeline event state changes
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet: async (contentType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user-timeline-event-state-changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTimelineEventStateChangesApi - functional programming interface
 * @export
 */
export const UserTimelineEventStateChangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTimelineEventStateChangesApiAxiosParamCreator(configuration)
    return {
        /**
         * List endpoint for user timeline event state changes implicitly filtered by the authenticated user ID.
         * @summary Lists all user timeline event state changes
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTimelineEventStateChangeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserTimelineEventStateChangesApi - factory interface
 * @export
 */
export const UserTimelineEventStateChangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTimelineEventStateChangesApiFp(configuration)
    return {
        /**
         * List endpoint for user timeline event state changes implicitly filtered by the authenticated user ID.
         * @summary Lists all user timeline event state changes
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType?: string, options?: any): AxiosPromise<UserTimelineEventStateChangeListResponse> {
            return localVarFp.getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTimelineEventStateChangesApi - object-oriented interface
 * @export
 * @class UserTimelineEventStateChangesApi
 * @extends {BaseAPI}
 */
export class UserTimelineEventStateChangesApi extends BaseAPI {
    /**
     * List endpoint for user timeline event state changes implicitly filtered by the authenticated user ID.
     * @summary Lists all user timeline event state changes
     * @param {string} [contentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTimelineEventStateChangesApi
     */
    public getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType?: string, options?: AxiosRequestConfig) {
        return UserTimelineEventStateChangesApiFp(this.configuration).getUserTimelineEventStateChangesV1UserTimelineEventStateChangesGet(contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserTimelineEventsApi - axios parameter creator
 * @export
 */
export const UserTimelineEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List endpoint for user timeline events ordered by step index (including events in an INITIAL state).
         * @summary Lists all timeline events for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimelineEventsForUserV1UserTimelineEventsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user-timeline-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch endpoint for user timeline events.
         * @summary Update a user timeline event
         * @param {string} timelineEventId 
         * @param {UserTimelineEventRequest} userTimelineEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch: async (timelineEventId: string, userTimelineEventRequest: UserTimelineEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timelineEventId' is not null or undefined
            assertParamExists('updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch', 'timelineEventId', timelineEventId)
            // verify required parameter 'userTimelineEventRequest' is not null or undefined
            assertParamExists('updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch', 'userTimelineEventRequest', userTimelineEventRequest)
            const localVarPath = `/v1/user-timeline-events/{timeline_event_id}`
                .replace(`{${"timeline_event_id"}}`, encodeURIComponent(String(timelineEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTimelineEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTimelineEventsApi - functional programming interface
 * @export
 */
export const UserTimelineEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTimelineEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * List endpoint for user timeline events ordered by step index (including events in an INITIAL state).
         * @summary Lists all timeline events for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimelineEventsForUserV1UserTimelineEventsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTimelineEventListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimelineEventsForUserV1UserTimelineEventsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch endpoint for user timeline events.
         * @summary Update a user timeline event
         * @param {string} timelineEventId 
         * @param {UserTimelineEventRequest} userTimelineEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId: string, userTimelineEventRequest: UserTimelineEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTimelineEventDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId, userTimelineEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserTimelineEventsApi - factory interface
 * @export
 */
export const UserTimelineEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTimelineEventsApiFp(configuration)
    return {
        /**
         * List endpoint for user timeline events ordered by step index (including events in an INITIAL state).
         * @summary Lists all timeline events for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimelineEventsForUserV1UserTimelineEventsGet(options?: any): AxiosPromise<UserTimelineEventListResponse> {
            return localVarFp.listTimelineEventsForUserV1UserTimelineEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Patch endpoint for user timeline events.
         * @summary Update a user timeline event
         * @param {string} timelineEventId 
         * @param {UserTimelineEventRequest} userTimelineEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId: string, userTimelineEventRequest: UserTimelineEventRequest, options?: any): AxiosPromise<UserTimelineEventDetailResponse> {
            return localVarFp.updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId, userTimelineEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTimelineEventsApi - object-oriented interface
 * @export
 * @class UserTimelineEventsApi
 * @extends {BaseAPI}
 */
export class UserTimelineEventsApi extends BaseAPI {
    /**
     * List endpoint for user timeline events ordered by step index (including events in an INITIAL state).
     * @summary Lists all timeline events for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTimelineEventsApi
     */
    public listTimelineEventsForUserV1UserTimelineEventsGet(options?: AxiosRequestConfig) {
        return UserTimelineEventsApiFp(this.configuration).listTimelineEventsForUserV1UserTimelineEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch endpoint for user timeline events.
     * @summary Update a user timeline event
     * @param {string} timelineEventId 
     * @param {UserTimelineEventRequest} userTimelineEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTimelineEventsApi
     */
    public updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId: string, userTimelineEventRequest: UserTimelineEventRequest, options?: AxiosRequestConfig) {
        return UserTimelineEventsApiFp(this.configuration).updateUserTimelineEventV1UserTimelineEventsTimelineEventIdPatch(timelineEventId, userTimelineEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new audience user for a Fictioneers powered experience.
         * @summary Create new audience user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1UsersPost: async (createUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUserV1UsersPost', 'createUserRequest', createUserRequest)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the user and any user associated objects from the current timeline.
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1UsersMeDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed representation of the current user (and user story state).
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMeV1UsersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Fictioneers API HTTP Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new audience user for a Fictioneers powered experience.
         * @summary Create new audience user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserV1UsersPost(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserV1UsersPost(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the user and any user associated objects from the current timeline.
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1UsersMeDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserV1UsersMeDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve detailed representation of the current user (and user story state).
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMeV1UsersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMeV1UsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new audience user for a Fictioneers powered experience.
         * @summary Create new audience user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1UsersPost(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.createUserV1UsersPost(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the user and any user associated objects from the current timeline.
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1UsersMeDelete(options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserV1UsersMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed representation of the current user (and user story state).
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMeV1UsersMeGet(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getUserMeV1UsersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new audience user for a Fictioneers powered experience.
     * @summary Create new audience user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserV1UsersPost(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserV1UsersPost(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the user and any user associated objects from the current timeline.
     * @summary Delete current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserV1UsersMeDelete(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserV1UsersMeDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed representation of the current user (and user story state).
     * @summary Retrieve current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserMeV1UsersMeGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserMeV1UsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


