import fetch from "node-fetch";
import { v4 as uuidv4 } from "uuid";

class Fictioneers {
  /**
   * A lightweight SDK interface to the Fictioneers API
   * @param {string} apiSecretKey
   * @param {(null|string)} userId
   * @returns {object}
   */
  constructor({ apiSecretKey, userId = null }) {
    if (userId == null) {
      userId = Fictioneers._uuidv4();
    }

    this.apiSecretKey = apiSecretKey;
    this.userId = userId;
    this.accessToken = null; // only create this the first time when needed
    this.accessTokenExpiry = null;
    this._endpoint = "https://api.fictioneers.co.uk/v1";
  }

  /**
   * generate and save a new ID Token which can be used to authenticate against the Audience APIs.
   * @returns {object}
   */
  async getAccessToken() {
    const response = await fetch(this._endpoint + "/auth/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: this.apiSecretKey,
      },
      body: JSON.stringify({
        user_id: this.userId,
      }),
    });

    const accessToken = await response.json();
    this.accessToken = accessToken.access_token;
    return {
      accessToken: accessToken.access_token,
      expiresIn: accessToken.expires_in,
    };
  }

  /**
   * Create a uuid v4 string
   * @returns {string}
   */
  static _uuidv4 = () => {
    return uuidv4();
  };

  /**
   * If necessary, generate and save a new ID Token which can be used to authenticate against the Audience APIs.
   * @returns {object}
   */
  async setAccessToken() {
    if (
      !this.accessToken ||
      this.accessTokenExpiry == null ||
      this.accessTokenExpiry < Date.now()
    ) {
      const { accessToken, expiresIn } = await this.getAccessToken();
      this.accessToken = accessToken;
      this.accessTokenExpiry = Date.now() + (expiresIn - 10) * 1000; // when the access token will expire, minus a period of 10 seconds
    }
    return {
      accessToken: this.accessToken,
      expiresIn: (this.accessTokenExpiry - Date.now()) / 1000 + 10,
    };
  }

  /**
   * Access the userId that may have been auto-generated by the SDK or supplied in the constructor.
   * @returns {string}
   */
  getUserId() {
    return this.userId;
  }

  /**
   * Sets the userId after the constructor is called (i.e., overwrites the userId passed to the constructor, or replaces the default created uuidv4)
   * @param {string} userId
   */
  async setUserId({ userId }) {
    if (userId.length) {
      this.userId = userId.toString();
      this.accessToken = null;
      await this.setAccessToken();
    } else {
      throw new Error("The parameter userId must have length");
    }
  }

  _getAuthHeaderSecretKey() {
    return {
      "Content-Type": "application/json",
      Accept: "application/json",
      Authorization: this.apiSecretKey,
    };
  }

  async _getAuthHeadersBearer() {
    await this.setAccessToken();
    if (!this.accessToken) {
      throw new Error(
        "Could not assemble auth headers with bearer - no access token"
      );
    }
    return {
      "Content-Type": "application/json",
      Accept: "application/json",
      Authorization: `Bearer ${this.accessToken}`,
    };
  }

  async _doFetch({
    url,
    method = "GET",
    auth = "bearer",
    body = null,
    deprecated = false,
  }) {
    let headers;
    if (auth === "bearer") {
      headers = await this._getAuthHeadersBearer();
    } else {
      headers = this._getAuthHeaderSecretKey();
    }

    const request = {
      method: method,
      headers: headers,
    };
    if ((method == "POST" || method == "PATCH") && body) {
      request.body = JSON.stringify(body);
    }
    const response = await fetch(this._endpoint + url, request);
    if (method === "DELETE") {
      return {
        data: null,
        error: !response.ok ? response.statusText : null,
        meta: null,
        status: 204,
      };
    }

    const r = await response.json();
    if (deprecated && !Array.isArray(r)) {
      r.error =
        (r.error ? r.error : "") +
        " Notice: this API endpoint has been deprecated and will be removed in a future version of this SDK.";
    }
    return r;
  }

  /* Admin */
  /* Admin service to programmatically manage timelines and timeline users. A secret API Key is required in the HTTP Authorization header. */

  /**
   * List all published timelines which users can be placed on.
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#list-all-published-timelines
   */
  async getTimelines() {
    return this._doFetch({
      url: "/timelines",
      auth: "key",
    });
  }

  /**
   * Representation of a single timeline.
   * @param {string} timelineId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#retrieves-timeline
   */
  async getTimeline({ timelineId }) {
    return this._doFetch({
      url: `/timelines/${timelineId}`,
      auth: "key",
    });
  }

  /**
   * Representation of a single timeline's events and metadata.
   * @param {string} timelineId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#lists-all-timeline-events-2
   */
  async getTimelineEvents({ timelineId }) {
    return this._doFetch({
      url: `/timelines/${timelineId}/timeline-events`,
      auth: "key",
    });
  }

  /**
   * List of all users on timeline.
   * @param {string} timelineId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#list-all-timeline-users
   */
  async getTimelineUsers({ timelineId }) {
    return this._doFetch({
      url: `/timelines/${timelineId}/users`,
      auth: "key",
    });
  }

  /**
   * Delete all users on a timeline.
   * @param {string} timelineId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#delete-all-timeline-users
   */
  async deleteTimelineUsers({ timelineId }) {
    return this._doFetch({
      url: `/timelines/${timelineId}/users`,
      method: "DELETE",
      auth: "key",
    });
  }

  /**
   * Retrieves timeline user.
   * @param {string} timelineId
   * @param {string} userId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#retrieves-timeline-user
   */
  async getTimelineUser({ timelineId, userId = null }) {
    if (userId == null) {
      userId = this.userId;
    }
    return this._doFetch({
      url: `/timelines/${timelineId}/users/${userId}`,
      auth: "key",
    });
  }

  /**
   * Delete timeline user.
   * @param {string} timelineId
   * @param {string} userId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#delete-timeline-user
   */
  async deleteTimelineUser({ timelineId, userId = null }) {
    if (userId == null) {
      userId = this.userId;
    }
    return this._doFetch({
      url: `/timelines/${timelineId}/users/${userId}`,
      method: "DELETE",
      auth: "key",
    });
  }

  /**
   * Returns all event state changes filtered by timeline.
   * @param {string} timelineId
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#list-all-event-state-changes-for-timeline
   */
  async getTimelineEventStateChanges({ timelineId }) {
    return this._doFetch({
      url: `/timelines/${timelineId}/event-state-changes/`,
      auth: "key",
    });
  }

  /* Users */
  /* User from the authentication token. */

  /**
   * Retrieve detailed representation of the current user.
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#retrieve-current-user
   */
  async getUser() {
    return this._doFetch({
      url: "/users/me",
    });
  }

  /**
   * Delete the user and any user associated objects from the current timeline.
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#delete-current-user
   */
  async deleteUser() {
    return this._doFetch({
      url: "/users/me",
      method: "DELETE",
    });
  }

  /**
   * Create a new audience user for a Fictioneers powered experience.
   * @param {string} timelineId
   * @param {boolean} disableTimeGuards
   * @param {boolean} pauseAtBeats
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#create-new-audience-user
   */
  async createUser({
    timelineId,
    disableTimeGuards = false,
    pauseAtBeats = false,
  }) {
    // TODO - does the user exist already?
    // await this.getUser()

    return this._doFetch({
      url: "/users",
      method: "POST",
      body: {
        published_timeline_id: timelineId,
        timezone: "Europe/London",
        disable_time_guards: disableTimeGuards,
        pause_at_beats: pauseAtBeats,
      },
    });
  }

  /** Shortcut / combined method to initialise a new user and progress them */
  async initialiseAndProgressUser({
    timelineId,
    disableTimeGuards = false,
    pauseAtBeats = false,
    maxSteps = null,
  }) {
    // first get or create the user, and get their story state
    let userStoryState;
    const getUserResponse = await this.getUser();
    if (getUserResponse.data == null) {
      const createUserResponse = await this.createUser({
        timelineId,
        disableTimeGuards,
        pauseAtBeats,
      });
      userStoryState = createUserResponse.data?.narrative_state;
    } else {
      const getUserStoryStateResponse = await this.getUserStoryState();
      userStoryState = getUserStoryStateResponse.data;
    }
    // progress the story state if they have just started:
    if (userStoryState?.current_step == null) {
      const progressUserStoryStateEventsResponse =
        await this.progressUserStoryStateEvents({ maxSteps, pauseAtBeats });
      userStoryState = progressUserStoryStateEventsResponse.data;
    }
    // next get their timeline events
    const userTimelineEventsResponse = await this.getUserTimelineEvents();
    const userTimelineEvents = userTimelineEventsResponse.data || [];
    // next put them on the timeline if not already
    if (
      userStoryState?.current_timeline_event_id == null &&
      userTimelineEvents.length > 0
    ) {
      const updateUserStoryStateResponse = await this.updateUserStoryState({
        currentTimelineEventId: userTimelineEvents[0].id,
      });
      userStoryState = updateUserStoryStateResponse.data;
    }
    return {
      userStoryState: userStoryState,
      userTimelineEvents: userTimelineEvents,
    };
  }

  /* User story state */
  /* User story state for the authenticated user. */

  /**
   * Representation of authenticated users narrative story state.
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#retrieves-user-narrative-state
   */
  async getUserStoryState() {
    return this._doFetch({
      url: "/user-story-state",
    });
  }

  /**
   * Updates current timeline event ID
   * @param {string} currentTimelineEventId
   * @returns {Promise}
   */
  async updateUserStoryState({ currentTimelineEventId }) {
    return this._doFetch({
      url: "/user-story-state",
      method: "PATCH",
      body: {
        current_timeline_event_id: currentTimelineEventId,
      },
    });
  }

  /**
   * Progress events based on the authenticated user available transition events.
   * @param {(null|number)} maxSteps
   * @param {boolean} pauseAtBeats
   * @returns {Promise}
   * @link https://storage.googleapis.com/fictioneers-developer-docs/build/index.html#progress-timeline-events
   */
  async progressUserStoryStateEvents({ maxSteps = null, pauseAtBeats = true }) {
    if (maxSteps !== null && typeof maxSteps == "string") {
      maxSteps = parseInt(maxSteps);
    }
    return this._doFetch({
      url: "/user-story-state/progress-events",
      method: "POST",
      body: {
        max_steps: maxSteps,
        pause_at_beats: pauseAtBeats,
      },
    });
  }

  /* User timeline events */

  /**
   * Gets all timeline events
   * @returns {Promise}
   */
  async getUserTimelineEvents() {
    return this._doFetch({
      url: "/user-timeline-events",
    });
  }

  /**
   * Marks a timeline event as COMPLETED (aka visited), or another state
   * @param {string} timelineEventId
   * @param {string} state
   * @returns {Promise}
   */
  async updateUserTimelineEvent({ timelineEventId, state }) {
    return this._doFetch({
      url: `/user-timeline-events/${timelineEventId}`,
      method: "PATCH",
      body: {
        state: state,
      },
    });
  }
}

export default Fictioneers;
